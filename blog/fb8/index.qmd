---
author: [Hank Gref, Jason Gyamfi, Haylee Pierce]
title: Parsing Inputs
date: '2023-11-'
date-format: long
categories: [post, software engineering, fuzzing book]
description: <em></em>
toc: true
page-layout: full
---

## Overview

This article covers the ["Parsing Inputs"](https://www.fuzzingbook.org/html/
Parser.html) chapter from [_Fuzzing Book_](https://www.fuzzingbook.org/). This 
chapter builds on the concepts from the ["Fuzzing with Grammars"](https://www.
fuzzingbook.org/html/Grammars.html) chapter and the ["Efficient Grammar 
Fuzzing"](https://www.fuzzingbook.org/html/GrammarFuzzer.html) chapter.

## Summary

This chapter uses grammars to parse a set of valid inputs and create derivation 
trees that can be used to fuzz, generate new valid inputs for testing. Two 
specific parsers are covered by the chapter: PEGParser and EarleyParser.

The **PEGParser** utilizes _predicate expression grammars (PEGs)_, which are 
very similar to _context-free grammars (CFGs)_. The one key difference between 
the two types of grammars is that PEGs will stop at the first rule that 
matches, while CFGs will match will all possible rules. Building the derivation 
tree with only the first matches is the PEGParser's way of resolving 
ambiguities. Below is an example of the PEGParser:

```python
class PEGParser(Parser):
    def parse_prefix(self, text):
        cursor, tree = self.unify_key(self.start_symbol(), text, 0)
        return cursor, [tree]
```

We can use this parser to create a derivation tree:

```python
mystring = "1 + (2 * 3)"
peg = PEGParser(EXPR_GRAMMAR)
for tree in peg.parse(mystring):
    assert tree_to_string(tree) == mystring
    display(display_tree(tree))
```

![The PEGParser Derivation Tree](derivation_tree1.PNG)

For the purpose of _fuzzing_, generation of strings, the use of the PEGParser 
is very effective. This is because a PEG cannot be reinterpretated as a CFG; 
therefore, a parser that uses CFGs is the best option.

The **EarleyParser** can use any CFG to parse. This parser will return all the 
possible derivation tree as a way to resolve ambiguities. These trees are 
returned in a list. An example of the EarleyParser is below:

```python
class EarleyParser(EarleyParser):
    def parse(self, text):
        cursor, states = self.parse_prefix(text)
        start = next((s for s in states if s.finished()), None)

        if cursor < len(text) or not start:
            raise SyntaxError("at " + repr(text[cursor:]))

        forest = self.parse_forest(self.table, start)
        for tree in self.extract_trees(forest):
            yield self.prune_tree(tree)
```

We can use this parser to create derivation trees:

```python
mystring = "1 + (2 * 3)"
earley = EarleyParser(EXPR_GRAMMAR)
for tree in earley.parse(mystring):
    assert tree_to_string(tree) == mystring
    display(display_tree(tree))
```

![The EarleyParser Derivation Tree](derivation_tree2.PNG)

## Reflection



## Use Cases



{{< include /_back-blog.qmd >}}
