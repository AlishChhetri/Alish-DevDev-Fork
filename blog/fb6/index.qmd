---
author: [Simon Jones, Hank Gref, Caleb Kendra]
title: Fuzzing with Grammars
date: '2023-10-20'
date-format: long
categories: [post, software engineering, fuzzing book, mutation]
description: <em>Here, we use a set of rules to create intelligently-fuzzed inputs.</em>
toc: true
page-layout: full
---

## Overview

This article discusses the [Fuzzing with
Grammars](https://www.fuzzingbook.org/html/Grammars.html) chapter from
[The Fuzzing Book](https://www.fuzzingbook.org/).

## Summary

Here is an example of a basic grammar for a word, similar to how most
programming languages would parse a variable identifier:

```
<start> ::= <word>
<word> ::= <word_char> | <word_char><word>
<word_char> ::= 
a | b | c | d | e | f | g | h | i | j | k | l | m | n | o | p | q | r | s | t | u | v | w | x | y | z | _
```

We represent many other things using this syntax, including arithmetic
expressions. Let's build a simple grammar-based fuzzer that takes a grammar as a
`Dict` input.

```{python}
import random
import re
from typing import Dict, List

Grammar = Dict[str, List[str]]

def nonterminals(expansion):
    return re.compile(r'(<[^<> ]*>)').findall(expansion)

class ExpansionError(Exception):
    pass

def simple_grammar_fuzzer(grammar: Grammar, 
                          start_symbol: str = "<start>",
                          max_nonterminals: int = 10,
                          max_expansion_trials: int = 100,
                          log: bool = False) -> str:
    """Produce a string from `grammar`.
       `start_symbol`: use a start symbol other than `<start>` (default).
       `max_nonterminals`: the maximum number of nonterminals 
         still left for expansion
       `max_expansion_trials`: maximum # of attempts to produce a string
       `log`: print expansion progress if True"""

    term = start_symbol
    expansion_trials = 0

    while len(nonterminals(term)) > 0:
        symbol_to_expand = random.choice(nonterminals(term))
        expansions = grammar[symbol_to_expand]
        expansion = random.choice(expansions)
        # In later chapters, we allow expansions to be tuples,
        # with the expansion being the first element
        if isinstance(expansion, tuple):
            expansion = expansion[0]

        new_term = term.replace(symbol_to_expand, expansion, 1)

        if len(nonterminals(new_term)) < max_nonterminals:
            term = new_term
            if log:
                print("%-40s" % (symbol_to_expand + " -> " + expansion), term)
            expansion_trials = 0
        else:
            expansion_trials += 1
            if expansion_trials >= max_expansion_trials:
                raise ExpansionError("Cannot expand " + repr(term))

    return term
```

Now we can fuzz intelligently with a grammar. This chapter provides the grammar
for URL, which we'll use:

```{python}
URL_GRAMMAR: Grammar = {
    "<start>":
        ["<url>"],
    "<url>":
        ["<scheme>://<authority><path><query>"],
    "<scheme>":
        ["http", "https", "ftp", "ftps"],
    "<authority>":
        ["<host>", "<host>:<port>", "<userinfo>@<host>", "<userinfo>@<host>:<port>"],
    "<host>":  # Just a few
        ["cispa.saarland", "www.google.com", "fuzzingbook.com"],
    "<port>":
        ["80", "8080", "<nat>"],
    "<nat>":
        ["<digit>", "<digit><digit>"],
    "<digit>":
        ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9"],
    "<userinfo>":  # Just one
        ["user:password"],
    "<path>":  # Just a few
        ["", "/", "/<id>"],
    "<id>":  # Just a few
        ["abc", "def", "x<digit><digit>"],
    "<query>":
        ["", "?<params>"],
    "<params>":
        ["<param>", "<param>&<params>"],
    "<param>":  # Just a few
        ["<id>=<id>", "<id>=<nat>"],
}
```

Now we can use it to see that the generated inputs are all valid URLs:

```{python}
for i in range(10):
    print(simple_grammar_fuzzer(grammar=URL_GRAMMAR, max_nonterminals=10))
```

The value `max_nonterminals` gives the fuzzer an upper limit on how many symbols
it can randomly generate until ending the expression.

Grammars can be used as a kind of way to seed an input before mutating it. This
way, instead of having a static seed for mutation, your seed can be randomized
as well. Just when you thought fuzzing could not get any deeper, right?

```{python}
n_grammar_seeds = 10
for i in range(n_grammar_seeds):
    original = simple_grammar_fuzzer(grammar=URL_GRAMMAR, max_nonterminals=10)
    mutated = multi_mutate(simple_grammar_fuzzer(grammar=URL_GRAMMAR, max_nonterminals=10), 5)
    print(f"original: {original}")
    print(f"mutated: {mutated}")
```

## Reflection

FIXME

## Use Cases

FIXME

{{< include /_back-blog.qmd >}}
