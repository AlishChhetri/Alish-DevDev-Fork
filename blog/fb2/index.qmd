---
author: [Mordred Boulais, Will Wolff, Gregory M. Kapfhammer]
title: Code Coverage
date: '2023-9-16'
date-format: long
categories: [post, software engineering, fuzzing book]
description: <em>How can we achieve the most possible code coverage?</em>
toc: true
page-layout: full
---

## Overview

This is our second post about the [The Fuzzing
Book](https://www.fuzzingbook.org/)! The goal of this post is to relate the
material from the book to our progress on our
[Chasten](https://github.com/AstuteSource/chasten) tool, with the hope that it
will provide valuable lessons on how we approach designing and developing our
own software. Part of this is guidance on automating tests, and how that may
look in different coding languages &mdash; although the article's main focus is
the Python programming language.

## Summary

The ["Code Coverage"](https://www.fuzzingbook.org/html/Coverage.html) chapter of
this book provides us with insight into specific sorts of tests and their
implementation.

The distinction between the tests is first highlighted in the comparison
between black-box and white-box testing, as specification versus
implementation. This sets the foundation for the chapter to discuss assorted
methods of running built-in methods to not only assess the existing coverage,
but also to automatically generate tests. Part of this is, as one may expect
with a title explicitly referencing it, going over the part fuzzing
tests/fuzzers play in this process.

White-box testing shows us a better understanding of where the code is failing
in the internal structure (*implementation*) and black-box testing reads and
tests *specific errors* and finds errors within a group. Both being sufficient
but both having flaws within each other but both work together to create great
software assurance to make a code work properly.

Example of black-box testing:

```python
assert cgi_decode('+') == ' '
assert cgi_decode('%20') == ' '
assert cgi_decode('abc') == 'abc'

try:
    cgi_decode('%?a')
    assert False
except ValueError:
    pass
```

This example highlights the fact that black-box testing is made for the specifics.
In this, case, specific assertions are made for specific characters. In contrast
to this, white-box covers larger segments, and checks if they happened correctly
when implemented. 

Part of this element of white-box testing is the *tracing*, which, in Python,
can be run automatically with the command `sys.settrace(f)`, `f` being a
tracing function, called for each line of code. From this, an assessment of code
coverage can also be made, which is to say the amount of code that has a test
case that checks it can be assessed. The higher the coverage the better, as it
provides some level of error-proofing and/or checking for all code covered.
As such, checking the coverage from automatically generated tests is a good
start to seeing if the tests are effective or not.
Then, once coverage is checked for several different methods of test creation,
it can be assessed which serves the purpose better. This is where *fuzzing* gets
brought in, as a form of testing which can be checked in this manner, and can be
useful where others may fail.

## Reflection

Notable elements of the chapter that we find worth further careful consideration
include the need to run coverage checks, how to automatically generate test
cases for our code, and the role which fuzzers might play in these efforts. In
order to complete the second item on this list, we may find it useful to employ
tracing functions, through which comparison of coverage may lead us to finding
the appropriate test generations for the segment of code in question, as different
sections may be better served by different styles.

The use of the code coverage is vital in software engineering, and methods such
as the black-box testing and white-box testing can supply the knowledge of if
there are any errors within the code.


## Action Items

It is now vital that we, as a team, put into action the ideas outlined here.
This chapter has also provided us with the knowledge as to how to go about it,
particularly because much of our work is in Python. As our teams create new features
and fix bugs, it is important that they also scan the coverage following their
improvements, and how to bring the coverage up to a more ideal level through the
generation of tests.

{{< include /_back-blog.qmd >}}
