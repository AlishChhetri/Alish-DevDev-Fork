---
author: [Mordred Boulais]
title: Code Coverage
date: '2023-9-16'
date-format: long
categories: [post, software engineering, fuzzing book]
description: <em>How can we achieve the most possible code coverage?</em>
toc: true
page-layout: full
---

## Overview

This is our second post about [The Fuzzing Book](https://www.fuzzingbook.org/)!
The goal of this post is to relate the material from the book to our progress on
our Chasten tool, with the hope that it will provide valuable lessons on how we
approach designing and developing our own software. Part of this is guidance on
automating tests, and how that may look in different coding languages, although
the main point of focus is on Python.


## Summary

The ["Code Coverage"](https://www.fuzzingbook.org/html/Coverage.html) chapter of
this book provides us with insight into specific sorts of tests and their
implementation. 

The distinction between the tests is first highlighted in the comparison between
black-box and white-box testing, as specification vs. implementation. This sets
the foundation for the chapter to discuss assorted methods of running built-in
methods to not only assess the existing coverage, but also to automatically
generate tests. Part of this is, as one may expect with a title explicitly
referrencing it, going over the part fuzzing tests/fuzzers play in this process.

White-box testing shows us a better understanding of where the code is failing in 
the internal structure (implementation) and black-box testing reads and tests
specific errors and finds errors within a group. Both being sufficient but both having 
flaws within each other but both work together to create great software assurance to 
make a code work properly.

Example of black-box testing:

```python
assert cgi_decode('+') == ' '
assert cgi_decode('%20') == ' '
assert cgi_decode('abc') == 'abc'

try:
    cgi_decode('%?a')
    assert False
except ValueError:
    pass
```

## Reflection

Notable elements of the chapter that we find worth further careful considertion
include the need to run coverage checks, how to automatically generate test
cases for our code, and the role which fuzzers might play in these efforts. In
order to complete the second item on this list, we may find it useful to employ
tracing functions.

The use of the code coverage is vital in software engineering. Methods such as
the black-box testing and white-box testing can ensures if there are any errors
within the code.


## Action Items

It is now vital that we, as a team, put into action the ideas outlined here.
This chapter has also provided us with the knowledge as to how to go about it,
particularly because much of our work is in Python. As our teams create new features
and fix bugs, it is important that they also scan the coverage following their
improvements, and how to bring the coverage up to a more ideal level through the
generation of tests.

{{< include /_back-blog.qmd >}}