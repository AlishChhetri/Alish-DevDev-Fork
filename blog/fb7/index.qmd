---
author: [Mordred Boulais, Miles Franck, Evan Nelson]
title: Efficient Grammar Fuzzing
date: '2023-10-30'
date-format: long
categories: [post, software engineering, fuzzing book]
description: <em>Implementing grammars for fuzzing.</em>
toc: true
page-layout: full
---

## Overview

This article discusses the
[Efficient Grammar Fuzzing](https://www.fuzzingbook.org/html/GrammarFuzzer.html)
chapter from [The Fuzzing Book](https://www.fuzzingbook.org/), exploring how its
content could potentially be useful to the development of our tool,
[chasten](https://github.com/AstuteSource/chasten). This article builds on the
[Fuzzing with Grammars](https://www.fuzzingbook.org/html/Grammars.html),to
pursue a better implementation. Let's dive into the details!

## Summary

This chapter opens with outlining the issues with the `simple_grammar_fuzzer`
introduced previously, which are that it is inefficient and hard to control. It
can continue adding parantheses indefinitely, for example, and has a complexity
of O(n^2) as part of this. Therefore **derivation trees** are now introduced,
which are a form of visualization for the steps of a grammar.

Below is an example of a tree built from the expression `2 + 2`.
![DerivationTreeExample](derivation_tree.PNG)

This representation works well for a higher level understanding, but is not a
feasible way to show in code as that stands. The code representation is possible
through the use of a combination of tuples and lists, using the formula
`(SYMBOL_NAME, CHILDREN)`. See below for an expanded example of this.

```python
DerivationTree = ("<start>",
                   [("<expr>",
                     [("<expr>", None),
                      (" + ", []),
                         ("<term>", None)]
                     )])
```

Each node has its own subnodes, until it reaches the outermost "leaves" of the
derivation tree. Using this, the chapter then outlines how to add functionality
for traversing and expanding nodes/whole trees using the methods it defines for
a `GrammarFuzzer` class. Below is an example of a method for expanding a node
randomly for fuzzing purposes.

```python
class GrammarFuzzer(GrammarFuzzer):
    def choose_node_expansion(self, node: DerivationTree,
                              children_alternatives: List[List[DerivationTree]]) -> int:
        """Return index of expansion in `children_alternatives` to be selected.
           'children_alternatives`: a list of possible children for `node`.
           Defaults to random. To be overloaded in subclasses."""
        return random.randrange(0, len(children_alternatives))
```

From there, limits are defined for maximum and minimum costs as another manner
of expanding that is less random. The minimum costs help with closing the tree,
to avoid some of the concerns about inefficiency surrounding the
`simple_grammar_fuzzer`. An example of expanding by minimum costs is presented
below.

```python
class GrammarFuzzer(GrammarFuzzer):
    def expand_node_min_cost(self, node: DerivationTree) -> DerivationTree:
        if self.log:
            print("Expanding", all_terminals(node), "at minimum cost")

        return self.expand_node_by_cost(node, min)
```

And then the expanding by maximum costs, good for using to start the tree,
displayd here.

```python
class GrammarFuzzer(GrammarFuzzer):
    def expand_node_max_cost(self, node: DerivationTree) -> DerivationTree:
        if self.log:
            print("Expanding", all_terminals(node), "at maximum cost")

        return self.expand_node_by_cost(node, max)
```

These three forms of expansion can be applied together in order to achieve
a more efficient form of fuzzing with grammars. By using the `GrammarFuzzer`
class and the methods created for it, tests can be generated much more quickly,
with the trade-off of creating smaller inputs that we have increased control
over.

## Reflection



## Use Cases

The implementation of efficient grammar fuzzing, as described in the chapter, offers a good opportunity for improving the testing of our code in the development of Chasten. Since our tool checks XPATH expressions, using the three-phase expansion approach would create a highly efficient testing tool. Here is an example of an xpath, //FunctionDef/element[position() = 3] this selects the third element node within a FunctionDef node. This specific pattern narrows down the selection to a particular position within the document structure, 
Exploring different variations or alterations of this pattern is essential in testing to cover diverse scenarios. An efficient fuzzer can generate a multitude of XPATH expressions with various modifications, like changing the positional value, using different node types, or incorporating additional conditions.




{{< include /_back-blog.qmd >}}
