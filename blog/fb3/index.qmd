---
author: [Finley Banas, Keller Liptrap, Simon Jones]
title: Fuzzing&#58; breaking things with random inputs
date: '2023-9-22'
date-format: long
categories: [post, software engineering, fuzzing book]
description: <em>Exploring how that we can make a robust test suite.</em>
toc: true
page-layout: full
---

## Summary

In this chapter in the Fuzzing Book, Fuzzing: Breaking Things with Random Inputs, we are taught
about using "Fuzzers" or programs that create random sections of numbers, letters, and symbols to
create a random test. One of the most basic examples could be realized by creating a "fuzz generator:"

```{python}
import random

def fuzzer(max_length: int = 100, char_start: int = 32, char_range: int = 32) -> str:
    """A string of up to `max_length` characters
       in the range [`char_start`, `char_start` + `char_range`)"""
    string_length = random.randrange(0, max_length + 1)
    out = ""
    for i in range(0, string_length):
        out += chr(random.randrange(char_start, char_start + char_range))
    return out
```

"Fuzzers" can quickly test various commands and random inputs. Suppose you had a function for
writing to a file, `scribe(data: str) -> None`. How would you know that a random sequence of bytes
is safe to write? You wouldn't without any notion of testing. We can easily test this using our
fuzzer function we just created:


```{python}
import os
import tempfile

def scribe(data: str) -> None:
    name = "file.txt"
    tempdir = tempfile.mkdtemp()
    FILE = os.path.join(tempdir, name)
    with open(FILE, "w") as f:
        f.write(data)

input_data = fuzzer()
scribe(input_data)
```

After running this through a few hundred iterations, we would begin to feel more comfortable
interfacing our `scribe()` function to a public API given that it doesn't break.

The chapter also discusses the concept of a `Runner`. `Runner()` is the component
responsible for executing the target application with the generated input. It captures the programâ€™s
behavior, logs crashes, and identifies potential vulnerabilities. The biggest hurdle within
`Fuzzing` is `hypothesis`, a complex Python library. There is a lot to learn to be able to properly
use this library as it is one of the hardest to understand. The chapter also goes into detail about
different `fuzzing` methods, like grammar-based and mutation-based `fuzzing`. 

## Reflection

Our team resonated with the importance of this chapter, as we have had many unnecessary issues arise
on our feature branches and are feeling the pains of not implementing fuzzing sooner. Our colleague
[Jason Gyamfi](https://storied-cendol-fb38cb.netlify.app/) states it frankly,

> This makes the chapter a must-read for those aiming to improve software strength and safety.

Our team is striving to do just that: "aiming to improve software strength and safety." While
starting the semester, some of us had not even heard of the term 'fuzzing.' Now, we all are aware of
the term, and some of us have even started implementing it into the test suite of
[chasten](https://github.com/astutesource/chasten/), our tool for finding patterns in the AST of a
python program.

We are all aware of the benefits of fuzzing and its keen ability to point out *stress points* in our
code. That said, the task remains to achieve complete familiarity with fuzzing strategies and to
consistently implement them when creating new features. Many of our team members have emphasized the
importance of doing this sooner than later, so as to not accrue *technical debt*. In our case, we
use [Hypothesis](https://hypothesis.readthedocs.io/en/latest/index.html), which offers many powerful
[strategies](https://hypothesis.readthedocs.io/en/latest/data.html) for fuzzing.

## Action Items

In this chapter of Fuzzing Book we the readers get a deeper understanding about the use of fuzzing
and the importance of testing in software engineering. Fuzzing which is used in this chapter to test
code can be very beneficial to finding weak points in code. The implementation of fuzzing into the
Chasten program could have many benefits. In Chasten we can check for bugs with inputting code or
using configure files. The use of fuzzing could also simulate a user's behavior which would give the
team an idea of bugs that a user may encounter. We have to apply what we have learned about fuzzing
in the following ways:

* **Have urgency:** When we see that a feature lacks proper test cases, rush to change that!
* **Be responsible:** When we write our own features, we need to make sure each change includes some
sort of test to verify that feature works with fuzzed input.
* **Be curious:** Explore tooling that exists in order to know every inch of its feature set. This
way, we can approach our testing the most effectively.

{{< include /_back-blog.qmd >}}
